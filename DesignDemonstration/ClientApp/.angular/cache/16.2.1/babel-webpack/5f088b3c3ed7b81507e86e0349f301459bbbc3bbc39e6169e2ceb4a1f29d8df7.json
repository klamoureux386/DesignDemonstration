{"ast":null,"code":"var _class, _class2, _class3;\n//----------------------\n// <auto-generated>\n//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\n// </auto-generated>\n//----------------------\n/* tslint:disable */\n/* eslint-disable */\n// ReSharper disable InconsistentNaming\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\nimport { InjectionToken } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport const API_BASE_URL = new InjectionToken('API_BASE_URL');\nexport class BandsClient {\n  constructor(http, baseUrl) {\n    this.jsonParseReviver = undefined;\n    this.http = http;\n    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n  }\n  getAll() {\n    let url_ = this.baseUrl + \"/Bands\";\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"application/json\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processGetAll(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processGetAll(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processGetAll(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    let _mappings = [];\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n        result200 = BandDTO.fromJS(resultData200, _mappings);\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  get(id) {\n    let url_ = this.baseUrl + \"/Bands/{id}\";\n    if (id === undefined || id === null) throw new Error(\"The parameter 'id' must be defined.\");\n    url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"application/json\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processGet(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processGet(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processGet(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    let _mappings = [];\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n        result200 = BandDTO.fromJS(resultData200, _mappings);\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n}\n_class = BandsClient;\n_class.ɵfac = function BandsClient_Factory(t) {\n  return new (t || _class)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(API_BASE_URL, 8));\n};\n_class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class,\n  factory: _class.ɵfac\n});\nexport class FeatherForecastClient {\n  constructor(http, baseUrl) {\n    this.jsonParseReviver = undefined;\n    this.http = http;\n    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n  }\n  get() {\n    let url_ = this.baseUrl + \"/FeatherForecast\";\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"application/json\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processGet(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processGet(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processGet(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    let _mappings = [];\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n        if (Array.isArray(resultData200)) {\n          result200 = [];\n          for (let item of resultData200) result200.push(WeatherForecast.fromJS(item, _mappings));\n        } else {\n          result200 = null;\n        }\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n}\n_class2 = FeatherForecastClient;\n_class2.ɵfac = function FeatherForecastClient_Factory(t) {\n  return new (t || _class2)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(API_BASE_URL, 8));\n};\n_class2.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class2,\n  factory: _class2.ɵfac\n});\nexport class WeatherForecastClient {\n  constructor(http, baseUrl) {\n    this.jsonParseReviver = undefined;\n    this.http = http;\n    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n  }\n  get() {\n    let url_ = this.baseUrl + \"/WeatherForecast\";\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"application/json\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processGet(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processGet(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processGet(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    let _mappings = [];\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n        if (Array.isArray(resultData200)) {\n          result200 = [];\n          for (let item of resultData200) result200.push(WeatherForecast.fromJS(item, _mappings));\n        } else {\n          result200 = null;\n        }\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n}\n_class3 = WeatherForecastClient;\n_class3.ɵfac = function WeatherForecastClient_Factory(t) {\n  return new (t || _class3)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(API_BASE_URL, 8));\n};\n_class3.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: _class3,\n  factory: _class3.ɵfac\n});\nexport class BandDTO {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n  init(_data, _mappings) {\n    if (_data) {\n      this.id = _data[\"id\"];\n      this.name = _data[\"name\"];\n      if (Array.isArray(_data[\"albumIds\"])) {\n        this.albumIds = [];\n        for (let item of _data[\"albumIds\"]) this.albumIds.push(item);\n      }\n      if (Array.isArray(_data[\"musicianIds\"])) {\n        this.musicianIds = [];\n        for (let item of _data[\"musicianIds\"]) this.musicianIds.push(item);\n      }\n    }\n  }\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, BandDTO);\n  }\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"id\"] = this.id;\n    data[\"name\"] = this.name;\n    if (Array.isArray(this.albumIds)) {\n      data[\"albumIds\"] = [];\n      for (let item of this.albumIds) data[\"albumIds\"].push(item);\n    }\n    if (Array.isArray(this.musicianIds)) {\n      data[\"musicianIds\"] = [];\n      for (let item of this.musicianIds) data[\"musicianIds\"].push(item);\n    }\n    return data;\n  }\n}\nexport class WeatherForecast {\n  constructor(data) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property)) this[property] = data[property];\n      }\n    }\n  }\n  init(_data, _mappings) {\n    if (_data) {\n      this.date = _data[\"date\"] ? new Date(_data[\"date\"].toString()) : undefined;\n      this.temperatureC = _data[\"temperatureC\"];\n      this.temperatureF = _data[\"temperatureF\"];\n      this.summary = _data[\"summary\"];\n    }\n  }\n  static fromJS(data, _mappings) {\n    data = typeof data === 'object' ? data : {};\n    return createInstance(data, _mappings, WeatherForecast);\n  }\n  toJSON(data) {\n    data = typeof data === 'object' ? data : {};\n    data[\"date\"] = this.date ? formatDate(this.date) : undefined;\n    data[\"temperatureC\"] = this.temperatureC;\n    data[\"temperatureF\"] = this.temperatureF;\n    data[\"summary\"] = this.summary;\n    return data;\n  }\n}\nfunction formatDate(d) {\n  return d.getFullYear() + '-' + (d.getMonth() < 9 ? '0' + (d.getMonth() + 1) : d.getMonth() + 1) + '-' + (d.getDate() < 10 ? '0' + d.getDate() : d.getDate());\n}\nfunction jsonParse(json, reviver) {\n  json = JSON.parse(json, reviver);\n  var byid = {};\n  var refs = [];\n  json = function recurse(obj, prop, parent) {\n    if (typeof obj !== 'object' || !obj) return obj;\n    if (\"$ref\" in obj) {\n      let ref = obj.$ref;\n      if (ref in byid) return byid[ref];\n      refs.push([parent, prop, ref]);\n      return undefined;\n    } else if (\"$id\" in obj) {\n      let id = obj.$id;\n      delete obj.$id;\n      if (\"$values\" in obj) obj = obj.$values;\n      byid[id] = obj;\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map((v, i) => recurse(v, i, obj));\n    } else {\n      for (var p in obj) {\n        if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object') obj[p] = recurse(obj[p], p, obj);\n      }\n    }\n    return obj;\n  }(json);\n  for (let i = 0; i < refs.length; i++) {\n    const ref = refs[i];\n    ref[0][ref[1]] = byid[ref[2]];\n  }\n  return json;\n}\nfunction createInstance(data, mappings, type) {\n  if (!mappings) mappings = [];\n  if (!data) return null;\n  const mappingIndexName = \"__mappingIndex\";\n  if (data[mappingIndexName]) return mappings[data[mappingIndexName]].target;\n  data[mappingIndexName] = mappings.length;\n  let result = new type();\n  mappings.push({\n    source: data,\n    target: result\n  });\n  result.init(data, mappings);\n  return result;\n}\nexport class ApiException extends Error {\n  constructor(message, status, response, headers, result) {\n    super();\n    this.isApiException = true;\n    this.message = message;\n    this.status = status;\n    this.response = response;\n    this.headers = headers;\n    this.result = result;\n  }\n  static isApiException(obj) {\n    return obj.isApiException === true;\n  }\n}\nfunction throwException(message, status, response, headers, result) {\n  if (result !== null && result !== undefined) return _observableThrow(result);else return _observableThrow(new ApiException(message, status, response, headers, null));\n}\nfunction blobToText(blob) {\n  return new Observable(observer => {\n    if (!blob) {\n      observer.next(\"\");\n      observer.complete();\n    } else {\n      let reader = new FileReader();\n      reader.onload = event => {\n        observer.next(event.target.result);\n        observer.complete();\n      };\n      reader.readAsText(blob);\n    }\n  });\n}","map":{"version":3,"names":["mergeMap","_observableMergeMap","catchError","_observableCatch","Observable","throwError","_observableThrow","of","_observableOf","InjectionToken","HttpClient","HttpHeaders","HttpResponse","HttpResponseBase","API_BASE_URL","BandsClient","constructor","http","baseUrl","jsonParseReviver","undefined","getAll","url_","replace","options_","observe","responseType","headers","request","pipe","response_","processGetAll","e","response","status","responseBlob","body","error","Blob","_headers","key","keys","get","_mappings","blobToText","_responseText","result200","resultData200","jsonParse","BandDTO","fromJS","throwException","id","Error","encodeURIComponent","processGet","i0","ɵɵinject","factory","ɵfac","FeatherForecastClient","Array","isArray","item","push","WeatherForecast","WeatherForecastClient","data","property","hasOwnProperty","init","_data","name","albumIds","musicianIds","createInstance","toJSON","date","Date","toString","temperatureC","temperatureF","summary","formatDate","d","getFullYear","getMonth","getDate","json","reviver","JSON","parse","byid","refs","recurse","obj","prop","parent","ref","$ref","$id","$values","map","v","i","p","length","mappings","type","mappingIndexName","target","result","source","ApiException","message","isApiException","blob","observer","next","complete","reader","FileReader","onload","event","readAsText"],"sources":["C:\\Users\\Halifex\\Documents\\Projects\\DesignDemonstration\\DesignDemonstration\\ClientApp\\src\\api.generated.clients.ts"],"sourcesContent":["//----------------------\r\n// <auto-generated>\r\n//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\r\n// </auto-generated>\r\n//----------------------\r\n\r\n/* tslint:disable */\r\n/* eslint-disable */\r\n// ReSharper disable InconsistentNaming\r\n\r\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\nexport interface IBandsClient {\r\n    getAll(): Observable<BandDTO>;\r\n    get(id: number): Observable<BandDTO>;\r\n}\r\n\r\n@Injectable()\r\nexport class BandsClient implements IBandsClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    getAll(): Observable<BandDTO> {\r\n        let url_ = this.baseUrl + \"/Bands\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGetAll(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGetAll(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<BandDTO>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<BandDTO>;\r\n        }));\r\n    }\r\n\r\n    protected processGetAll(response: HttpResponseBase): Observable<BandDTO> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        let _mappings: { source: any, target: any }[] = [];\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\r\n            result200 = BandDTO.fromJS(resultData200, _mappings);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    get(id: number): Observable<BandDTO> {\r\n        let url_ = this.baseUrl + \"/Bands/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGet(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGet(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<BandDTO>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<BandDTO>;\r\n        }));\r\n    }\r\n\r\n    protected processGet(response: HttpResponseBase): Observable<BandDTO> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        let _mappings: { source: any, target: any }[] = [];\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\r\n            result200 = BandDTO.fromJS(resultData200, _mappings);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport interface IFeatherForecastClient {\r\n    get(): Observable<WeatherForecast[]>;\r\n}\r\n\r\n@Injectable()\r\nexport class FeatherForecastClient implements IFeatherForecastClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    get(): Observable<WeatherForecast[]> {\r\n        let url_ = this.baseUrl + \"/FeatherForecast\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGet(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGet(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;\r\n        }));\r\n    }\r\n\r\n    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        let _mappings: { source: any, target: any }[] = [];\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(WeatherForecast.fromJS(item, _mappings));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport interface IWeatherForecastClient {\r\n    get(): Observable<WeatherForecast[]>;\r\n}\r\n\r\n@Injectable()\r\nexport class WeatherForecastClient implements IWeatherForecastClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    get(): Observable<WeatherForecast[]> {\r\n        let url_ = this.baseUrl + \"/WeatherForecast\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGet(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGet(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;\r\n        }));\r\n    }\r\n\r\n    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        let _mappings: { source: any, target: any }[] = [];\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(WeatherForecast.fromJS(item, _mappings));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class BandDTO implements IBandDTO {\r\n    id!: number;\r\n    name!: string;\r\n    albumIds!: number[];\r\n    musicianIds!: number[];\r\n\r\n    constructor(data?: IBandDTO) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any, _mappings?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            if (Array.isArray(_data[\"albumIds\"])) {\r\n                this.albumIds = [] as any;\r\n                for (let item of _data[\"albumIds\"])\r\n                    this.albumIds!.push(item);\r\n            }\r\n            if (Array.isArray(_data[\"musicianIds\"])) {\r\n                this.musicianIds = [] as any;\r\n                for (let item of _data[\"musicianIds\"])\r\n                    this.musicianIds!.push(item);\r\n            }\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any, _mappings?: any): BandDTO | null {\r\n        data = typeof data === 'object' ? data : {};\r\n        return createInstance<BandDTO>(data, _mappings, BandDTO);\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        if (Array.isArray(this.albumIds)) {\r\n            data[\"albumIds\"] = [];\r\n            for (let item of this.albumIds)\r\n                data[\"albumIds\"].push(item);\r\n        }\r\n        if (Array.isArray(this.musicianIds)) {\r\n            data[\"musicianIds\"] = [];\r\n            for (let item of this.musicianIds)\r\n                data[\"musicianIds\"].push(item);\r\n        }\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IBandDTO {\r\n    id: number;\r\n    name: string;\r\n    albumIds: number[];\r\n    musicianIds: number[];\r\n}\r\n\r\nexport class WeatherForecast implements IWeatherForecast {\r\n    date!: Date;\r\n    temperatureC!: number;\r\n    temperatureF!: number;\r\n    summary!: string | undefined;\r\n\r\n    constructor(data?: IWeatherForecast) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any, _mappings?: any) {\r\n        if (_data) {\r\n            this.date = _data[\"date\"] ? new Date(_data[\"date\"].toString()) : <any>undefined;\r\n            this.temperatureC = _data[\"temperatureC\"];\r\n            this.temperatureF = _data[\"temperatureF\"];\r\n            this.summary = _data[\"summary\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any, _mappings?: any): WeatherForecast | null {\r\n        data = typeof data === 'object' ? data : {};\r\n        return createInstance<WeatherForecast>(data, _mappings, WeatherForecast);\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"date\"] = this.date ? formatDate(this.date) : <any>undefined;\r\n        data[\"temperatureC\"] = this.temperatureC;\r\n        data[\"temperatureF\"] = this.temperatureF;\r\n        data[\"summary\"] = this.summary;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IWeatherForecast {\r\n    date: Date;\r\n    temperatureC: number;\r\n    temperatureF: number;\r\n    summary: string | undefined;\r\n}\r\n\r\nfunction formatDate(d: Date) {\r\n    return d.getFullYear() + '-' + \r\n        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +\r\n        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());\r\n}\r\n\r\nfunction jsonParse(json: any, reviver?: any) {\r\n    json = JSON.parse(json, reviver);\r\n\r\n    var byid: any = {};\r\n    var refs: any = [];\r\n    json = (function recurse(obj: any, prop?: any, parent?: any) {\r\n        if (typeof obj !== 'object' || !obj)\r\n            return obj;\r\n        \r\n        if (\"$ref\" in obj) {\r\n            let ref = obj.$ref;\r\n            if (ref in byid)\r\n                return byid[ref];\r\n            refs.push([parent, prop, ref]);\r\n            return undefined;\r\n        } else if (\"$id\" in obj) {\r\n            let id = obj.$id;\r\n            delete obj.$id;\r\n            if (\"$values\" in obj)\r\n                obj = obj.$values;\r\n            byid[id] = obj;\r\n        }\r\n        \r\n        if (Array.isArray(obj)) {\r\n            obj = obj.map((v, i) => recurse(v, i, obj));\r\n        } else {\r\n            for (var p in obj) {\r\n                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')\r\n                    obj[p] = recurse(obj[p], p, obj);\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    })(json);\r\n\r\n    for (let i = 0; i < refs.length; i++) {\r\n        const ref = refs[i];\r\n        ref[0][ref[1]] = byid[ref[2]];\r\n    }\r\n\r\n    return json;\r\n}\r\n\r\nfunction createInstance<T>(data: any, mappings: any, type: any): T | null {\r\n  if (!mappings)\r\n    mappings = [];\r\n  if (!data)\r\n    return null;\r\n\r\n  const mappingIndexName = \"__mappingIndex\";\r\n  if (data[mappingIndexName])\r\n    return <T>mappings[data[mappingIndexName]].target;\r\n\r\n  data[mappingIndexName] = mappings.length;\r\n\r\n  let result: any = new type();\r\n  mappings.push({ source: data, target: result });\r\n  result.init(data, mappings);\r\n  return result;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}