{"ast":null,"code":"//----------------------\n// <auto-generated>\n//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\n// </auto-generated>\n//----------------------\n/* tslint:disable */\n/* eslint-disable */\n// ReSharper disable InconsistentNaming\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport var clients;\n(function (clients, _class, _class2, _class3) {\n  clients.API_BASE_URL = new InjectionToken('API_BASE_URL');\n  class BandsClient {\n    constructor(http, baseUrl) {\n      this.jsonParseReviver = undefined;\n      this.http = http;\n      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n    }\n    get(id) {\n      let url_ = this.baseUrl + \"/Bands/{id}\";\n      if (id === undefined || id === null) throw new Error(\"The parameter 'id' must be defined.\");\n      url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\n      url_ = url_.replace(/[?&]$/, \"\");\n      let options_ = {\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processGet(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processGet(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n    processGet(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n      let _mappings = [];\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          result200 = BandDTO.fromJS(resultData200, _mappings);\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n      return _observableOf(null);\n    }\n  }\n  _class = BandsClient;\n  _class.ɵfac = function BandsClient_Factory(t) {\n    return new (t || _class)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(clients.API_BASE_URL, 8));\n  };\n  _class.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class,\n    factory: _class.ɵfac\n  });\n  clients.BandsClient = BandsClient;\n  class FeatherForecastClient {\n    constructor(http, baseUrl) {\n      this.jsonParseReviver = undefined;\n      this.http = http;\n      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n    }\n    get() {\n      let url_ = this.baseUrl + \"/FeatherForecast\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      let options_ = {\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processGet(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processGet(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n    processGet(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n      let _mappings = [];\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          if (Array.isArray(resultData200)) {\n            result200 = [];\n            for (let item of resultData200) result200.push(WeatherForecast.fromJS(item, _mappings));\n          } else {\n            result200 = null;\n          }\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n      return _observableOf(null);\n    }\n  }\n  _class2 = FeatherForecastClient;\n  _class2.ɵfac = function FeatherForecastClient_Factory(t) {\n    return new (t || _class2)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(clients.API_BASE_URL, 8));\n  };\n  _class2.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class2,\n    factory: _class2.ɵfac\n  });\n  clients.FeatherForecastClient = FeatherForecastClient;\n  class WeatherForecastClient {\n    constructor(http, baseUrl) {\n      this.jsonParseReviver = undefined;\n      this.http = http;\n      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n    }\n    get() {\n      let url_ = this.baseUrl + \"/WeatherForecast\";\n      url_ = url_.replace(/[?&]$/, \"\");\n      let options_ = {\n        observe: \"response\",\n        responseType: \"blob\",\n        headers: new HttpHeaders({\n          \"Accept\": \"application/json\"\n        })\n      };\n      return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n        return this.processGet(response_);\n      })).pipe(_observableCatch(response_ => {\n        if (response_ instanceof HttpResponseBase) {\n          try {\n            return this.processGet(response_);\n          } catch (e) {\n            return _observableThrow(e);\n          }\n        } else return _observableThrow(response_);\n      }));\n    }\n    processGet(response) {\n      const status = response.status;\n      const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n      let _headers = {};\n      if (response.headers) {\n        for (let key of response.headers.keys()) {\n          _headers[key] = response.headers.get(key);\n        }\n      }\n      let _mappings = [];\n      if (status === 200) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          let result200 = null;\n          let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\n          if (Array.isArray(resultData200)) {\n            result200 = [];\n            for (let item of resultData200) result200.push(WeatherForecast.fromJS(item, _mappings));\n          } else {\n            result200 = null;\n          }\n          return _observableOf(result200);\n        }));\n      } else if (status !== 200 && status !== 204) {\n        return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n          return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n        }));\n      }\n      return _observableOf(null);\n    }\n  }\n  _class3 = WeatherForecastClient;\n  _class3.ɵfac = function WeatherForecastClient_Factory(t) {\n    return new (t || _class3)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(clients.API_BASE_URL, 8));\n  };\n  _class3.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: _class3,\n    factory: _class3.ɵfac\n  });\n  clients.WeatherForecastClient = WeatherForecastClient;\n  class BandDTO {\n    constructor(data) {\n      if (data) {\n        for (var property in data) {\n          if (data.hasOwnProperty(property)) this[property] = data[property];\n        }\n      }\n    }\n    init(_data, _mappings) {\n      if (_data) {\n        this.id = _data[\"id\"];\n        this.name = _data[\"name\"];\n        if (Array.isArray(_data[\"albumIds\"])) {\n          this.albumIds = [];\n          for (let item of _data[\"albumIds\"]) this.albumIds.push(item);\n        }\n        if (Array.isArray(_data[\"musicianIds\"])) {\n          this.musicianIds = [];\n          for (let item of _data[\"musicianIds\"]) this.musicianIds.push(item);\n        }\n      }\n    }\n    static fromJS(data, _mappings) {\n      data = typeof data === 'object' ? data : {};\n      return createInstance(data, _mappings, BandDTO);\n    }\n    toJSON(data) {\n      data = typeof data === 'object' ? data : {};\n      data[\"id\"] = this.id;\n      data[\"name\"] = this.name;\n      if (Array.isArray(this.albumIds)) {\n        data[\"albumIds\"] = [];\n        for (let item of this.albumIds) data[\"albumIds\"].push(item);\n      }\n      if (Array.isArray(this.musicianIds)) {\n        data[\"musicianIds\"] = [];\n        for (let item of this.musicianIds) data[\"musicianIds\"].push(item);\n      }\n      return data;\n    }\n  }\n  clients.BandDTO = BandDTO;\n  class WeatherForecast {\n    constructor(data) {\n      if (data) {\n        for (var property in data) {\n          if (data.hasOwnProperty(property)) this[property] = data[property];\n        }\n      }\n    }\n    init(_data, _mappings) {\n      if (_data) {\n        this.date = _data[\"date\"] ? new Date(_data[\"date\"].toString()) : undefined;\n        this.temperatureC = _data[\"temperatureC\"];\n        this.temperatureF = _data[\"temperatureF\"];\n        this.summary = _data[\"summary\"];\n      }\n    }\n    static fromJS(data, _mappings) {\n      data = typeof data === 'object' ? data : {};\n      return createInstance(data, _mappings, WeatherForecast);\n    }\n    toJSON(data) {\n      data = typeof data === 'object' ? data : {};\n      data[\"date\"] = this.date ? formatDate(this.date) : undefined;\n      data[\"temperatureC\"] = this.temperatureC;\n      data[\"temperatureF\"] = this.temperatureF;\n      data[\"summary\"] = this.summary;\n      return data;\n    }\n  }\n  clients.WeatherForecast = WeatherForecast;\n  function formatDate(d) {\n    return d.getFullYear() + '-' + (d.getMonth() < 9 ? '0' + (d.getMonth() + 1) : d.getMonth() + 1) + '-' + (d.getDate() < 10 ? '0' + d.getDate() : d.getDate());\n  }\n  function jsonParse(json, reviver) {\n    json = JSON.parse(json, reviver);\n    var byid = {};\n    var refs = [];\n    json = function recurse(obj, prop, parent) {\n      if (typeof obj !== 'object' || !obj) return obj;\n      if (\"$ref\" in obj) {\n        let ref = obj.$ref;\n        if (ref in byid) return byid[ref];\n        refs.push([parent, prop, ref]);\n        return undefined;\n      } else if (\"$id\" in obj) {\n        let id = obj.$id;\n        delete obj.$id;\n        if (\"$values\" in obj) obj = obj.$values;\n        byid[id] = obj;\n      }\n      if (Array.isArray(obj)) {\n        obj = obj.map((v, i) => recurse(v, i, obj));\n      } else {\n        for (var p in obj) {\n          if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object') obj[p] = recurse(obj[p], p, obj);\n        }\n      }\n      return obj;\n    }(json);\n    for (let i = 0; i < refs.length; i++) {\n      const ref = refs[i];\n      ref[0][ref[1]] = byid[ref[2]];\n    }\n    return json;\n  }\n  function createInstance(data, mappings, type) {\n    if (!mappings) mappings = [];\n    if (!data) return null;\n    const mappingIndexName = \"__mappingIndex\";\n    if (data[mappingIndexName]) return mappings[data[mappingIndexName]].target;\n    data[mappingIndexName] = mappings.length;\n    let result = new type();\n    mappings.push({\n      source: data,\n      target: result\n    });\n    result.init(data, mappings);\n    return result;\n  }\n  class ApiException extends Error {\n    constructor(message, status, response, headers, result) {\n      super();\n      this.isApiException = true;\n      this.message = message;\n      this.status = status;\n      this.response = response;\n      this.headers = headers;\n      this.result = result;\n    }\n    static isApiException(obj) {\n      return obj.isApiException === true;\n    }\n  }\n  clients.ApiException = ApiException;\n  function throwException(message, status, response, headers, result) {\n    if (result !== null && result !== undefined) return _observableThrow(result);else return _observableThrow(new ApiException(message, status, response, headers, null));\n  }\n  function blobToText(blob) {\n    return new Observable(observer => {\n      if (!blob) {\n        observer.next(\"\");\n        observer.complete();\n      } else {\n        let reader = new FileReader();\n        reader.onload = event => {\n          observer.next(event.target.result);\n          observer.complete();\n        };\n        reader.readAsText(blob);\n      }\n    });\n  }\n})(clients || (clients = {}));","map":{"version":3,"names":["mergeMap","_observableMergeMap","catchError","_observableCatch","Observable","throwError","_observableThrow","of","_observableOf","Injectable","Inject","Optional","InjectionToken","HttpClient","HttpHeaders","HttpResponse","HttpResponseBase","clients","_class","_class2","_class3","API_BASE_URL","BandsClient","constructor","http","baseUrl","jsonParseReviver","undefined","get","id","url_","Error","replace","encodeURIComponent","options_","observe","responseType","headers","request","pipe","response_","processGet","e","response","status","responseBlob","body","error","Blob","_headers","key","keys","_mappings","blobToText","_responseText","result200","resultData200","jsonParse","BandDTO","fromJS","throwException","i0","ɵɵinject","factory","ɵfac","FeatherForecastClient","Array","isArray","item","push","WeatherForecast","WeatherForecastClient","data","property","hasOwnProperty","init","_data","name","albumIds","musicianIds","createInstance","toJSON","date","Date","toString","temperatureC","temperatureF","summary","formatDate","d","getFullYear","getMonth","getDate","json","reviver","JSON","parse","byid","refs","recurse","obj","prop","parent","ref","$ref","$id","$values","map","v","i","p","length","mappings","type","mappingIndexName","target","result","source","ApiException","message","isApiException","blob","observer","next","complete","reader","FileReader","onload","event","readAsText"],"sources":["C:\\Users\\Halifex\\Documents\\Projects\\DesignDemonstration\\DesignDemonstration\\ClientApp\\src\\api.generated.clients.ts"],"sourcesContent":["//----------------------\r\n// <auto-generated>\r\n//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\r\n// </auto-generated>\r\n//----------------------\r\n\r\n/* tslint:disable */\r\n/* eslint-disable */\r\n// ReSharper disable InconsistentNaming\r\n\r\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport module clients {\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\nexport interface IBandsClient {\r\n    get(id: number): Observable<BandDTO>;\r\n}\r\n\r\n@Injectable()\r\nexport class BandsClient implements IBandsClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    get(id: number): Observable<BandDTO> {\r\n        let url_ = this.baseUrl + \"/Bands/{id}\";\r\n        if (id === undefined || id === null)\r\n            throw new Error(\"The parameter 'id' must be defined.\");\r\n        url_ = url_.replace(\"{id}\", encodeURIComponent(\"\" + id));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGet(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGet(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<BandDTO>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<BandDTO>;\r\n        }));\r\n    }\r\n\r\n    protected processGet(response: HttpResponseBase): Observable<BandDTO> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        let _mappings: { source: any, target: any }[] = [];\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\r\n            result200 = BandDTO.fromJS(resultData200, _mappings);\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport interface IFeatherForecastClient {\r\n    get(): Observable<WeatherForecast[]>;\r\n}\r\n\r\n@Injectable()\r\nexport class FeatherForecastClient implements IFeatherForecastClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    get(): Observable<WeatherForecast[]> {\r\n        let url_ = this.baseUrl + \"/FeatherForecast\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGet(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGet(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;\r\n        }));\r\n    }\r\n\r\n    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        let _mappings: { source: any, target: any }[] = [];\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(WeatherForecast.fromJS(item, _mappings));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport interface IWeatherForecastClient {\r\n    get(): Observable<WeatherForecast[]>;\r\n}\r\n\r\n@Injectable()\r\nexport class WeatherForecastClient implements IWeatherForecastClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    get(): Observable<WeatherForecast[]> {\r\n        let url_ = this.baseUrl + \"/WeatherForecast\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"application/json\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processGet(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processGet(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<WeatherForecast[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<WeatherForecast[]>;\r\n        }));\r\n    }\r\n\r\n    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        let _mappings: { source: any, target: any }[] = [];\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            let resultData200 = _responseText === \"\" ? null : jsonParse(_responseText, this.jsonParseReviver);\r\n            if (Array.isArray(resultData200)) {\r\n                result200 = [] as any;\r\n                for (let item of resultData200)\r\n                    result200!.push(WeatherForecast.fromJS(item, _mappings));\r\n            }\r\n            else {\r\n                result200 = <any>null;\r\n            }\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport class BandDTO implements IBandDTO {\r\n    id!: number;\r\n    name!: string;\r\n    albumIds!: number[];\r\n    musicianIds!: number[];\r\n\r\n    constructor(data?: IBandDTO) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any, _mappings?: any) {\r\n        if (_data) {\r\n            this.id = _data[\"id\"];\r\n            this.name = _data[\"name\"];\r\n            if (Array.isArray(_data[\"albumIds\"])) {\r\n                this.albumIds = [] as any;\r\n                for (let item of _data[\"albumIds\"])\r\n                    this.albumIds!.push(item);\r\n            }\r\n            if (Array.isArray(_data[\"musicianIds\"])) {\r\n                this.musicianIds = [] as any;\r\n                for (let item of _data[\"musicianIds\"])\r\n                    this.musicianIds!.push(item);\r\n            }\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any, _mappings?: any): BandDTO | null {\r\n        data = typeof data === 'object' ? data : {};\r\n        return createInstance<BandDTO>(data, _mappings, BandDTO);\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"id\"] = this.id;\r\n        data[\"name\"] = this.name;\r\n        if (Array.isArray(this.albumIds)) {\r\n            data[\"albumIds\"] = [];\r\n            for (let item of this.albumIds)\r\n                data[\"albumIds\"].push(item);\r\n        }\r\n        if (Array.isArray(this.musicianIds)) {\r\n            data[\"musicianIds\"] = [];\r\n            for (let item of this.musicianIds)\r\n                data[\"musicianIds\"].push(item);\r\n        }\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IBandDTO {\r\n    id: number;\r\n    name: string;\r\n    albumIds: number[];\r\n    musicianIds: number[];\r\n}\r\n\r\nexport class WeatherForecast implements IWeatherForecast {\r\n    date!: Date;\r\n    temperatureC!: number;\r\n    temperatureF!: number;\r\n    summary!: string | undefined;\r\n\r\n    constructor(data?: IWeatherForecast) {\r\n        if (data) {\r\n            for (var property in data) {\r\n                if (data.hasOwnProperty(property))\r\n                    (<any>this)[property] = (<any>data)[property];\r\n            }\r\n        }\r\n    }\r\n\r\n    init(_data?: any, _mappings?: any) {\r\n        if (_data) {\r\n            this.date = _data[\"date\"] ? new Date(_data[\"date\"].toString()) : <any>undefined;\r\n            this.temperatureC = _data[\"temperatureC\"];\r\n            this.temperatureF = _data[\"temperatureF\"];\r\n            this.summary = _data[\"summary\"];\r\n        }\r\n    }\r\n\r\n    static fromJS(data: any, _mappings?: any): WeatherForecast | null {\r\n        data = typeof data === 'object' ? data : {};\r\n        return createInstance<WeatherForecast>(data, _mappings, WeatherForecast);\r\n    }\r\n\r\n    toJSON(data?: any) {\r\n        data = typeof data === 'object' ? data : {};\r\n        data[\"date\"] = this.date ? formatDate(this.date) : <any>undefined;\r\n        data[\"temperatureC\"] = this.temperatureC;\r\n        data[\"temperatureF\"] = this.temperatureF;\r\n        data[\"summary\"] = this.summary;\r\n        return data;\r\n    }\r\n}\r\n\r\nexport interface IWeatherForecast {\r\n    date: Date;\r\n    temperatureC: number;\r\n    temperatureF: number;\r\n    summary: string | undefined;\r\n}\r\n\r\nfunction formatDate(d: Date) {\r\n    return d.getFullYear() + '-' + \r\n        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +\r\n        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());\r\n}\r\n\r\nfunction jsonParse(json: any, reviver?: any) {\r\n    json = JSON.parse(json, reviver);\r\n\r\n    var byid: any = {};\r\n    var refs: any = [];\r\n    json = (function recurse(obj: any, prop?: any, parent?: any) {\r\n        if (typeof obj !== 'object' || !obj)\r\n            return obj;\r\n        \r\n        if (\"$ref\" in obj) {\r\n            let ref = obj.$ref;\r\n            if (ref in byid)\r\n                return byid[ref];\r\n            refs.push([parent, prop, ref]);\r\n            return undefined;\r\n        } else if (\"$id\" in obj) {\r\n            let id = obj.$id;\r\n            delete obj.$id;\r\n            if (\"$values\" in obj)\r\n                obj = obj.$values;\r\n            byid[id] = obj;\r\n        }\r\n        \r\n        if (Array.isArray(obj)) {\r\n            obj = obj.map((v, i) => recurse(v, i, obj));\r\n        } else {\r\n            for (var p in obj) {\r\n                if (obj.hasOwnProperty(p) && obj[p] && typeof obj[p] === 'object')\r\n                    obj[p] = recurse(obj[p], p, obj);\r\n            }\r\n        }\r\n\r\n        return obj;\r\n    })(json);\r\n\r\n    for (let i = 0; i < refs.length; i++) {\r\n        const ref = refs[i];\r\n        ref[0][ref[1]] = byid[ref[2]];\r\n    }\r\n\r\n    return json;\r\n}\r\n\r\nfunction createInstance<T>(data: any, mappings: any, type: any): T | null {\r\n  if (!mappings)\r\n    mappings = [];\r\n  if (!data)\r\n    return null;\r\n\r\n  const mappingIndexName = \"__mappingIndex\";\r\n  if (data[mappingIndexName])\r\n    return <T>mappings[data[mappingIndexName]].target;\r\n\r\n  data[mappingIndexName] = mappings.length;\r\n\r\n  let result: any = new type();\r\n  mappings.push({ source: data, target: result });\r\n  result.init(data, mappings);\r\n  return result;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}\r\n\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}